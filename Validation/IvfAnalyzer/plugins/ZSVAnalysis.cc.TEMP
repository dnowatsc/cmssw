// user include files
//#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/Framework/interface/ESHandle.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "DataFormats/VertexReco/interface/Vertex.h"
#include "DataFormats/GeometryVector/interface/GlobalVector.h"
#include "DataFormats/Candidate/interface/LeafCandidate.h"
#include "DataFormats/TrackReco/interface/Track.h"
#include "DataFormats/Math/interface/deltaR.h"
#include "DataFormats/Math/interface/deltaPhi.h"

#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Electron.h"
#include "DataFormats/PatCandidates/interface/MET.h"
#include "DataFormats/PatCandidates/interface/Jet.h"

// simulation:
#include "SimDataFormats/PileupSummaryInfo/interface/PileupSummaryInfo.h"
#include "SimDataFormats/GeneratorProducts/interface/GenEventInfoProduct.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"

#include "RecoBTag/SecondaryVertex/interface/SecondaryVertex.h"

#include "CommonTools/UtilAlgos/interface/TFileService.h"

#include "TTree.h"
#include "HepPDT/ParticleID.hh"

#include "ZSVAnalysis/TreeMaker/interface/zsvtree.hpp"



//#include <memory>
//#include <TLorentzVector.h>

using namespace edm;
using namespace reco;
using namespace pat;
using namespace std;


namespace{
    
    
struct Bhadron {
   LorentzVector p4;
   reco::SecondaryVertex vertex;
   GlobalVector flightdir;
   bool isSelected;
};

struct compareBCandbyPt {  
  bool operator()( const Bhadron & BCand1, const Bhadron & BCand2 ) const {
    return BCand1.p4.Pt() > BCand2.p4.Pt();
  }
};
    
double isolation_pat_ea04(const pat::Muon & mu, double central_neutral_rho){

    double eta = fabs(mu.eta());
    
    // see https://indico.cern.ch/getFile.py/access?contribId=1&resId=0&materialId=slides&confId=188494 page 9
    // (via muon id twiki page, see below)
    double A_eff;
    if(eta < 1.0) A_eff = 0.674;
    else if(eta < 1.5) A_eff = 0.565;
    else if(eta < 2.0) A_eff = 0.442;
    else if(eta < 2.2) A_eff = 0.515;
    else if(eta < 2.3) A_eff = 0.821;
    else A_eff = 0.660;
    
    // see https://twiki.cern.ch/twiki/bin/view/CMSPublic/SWGuideMuonId  Isolation
    return (mu.chargedHadronIso() + std::max(mu.neutralHadronIso() + mu.photonIso() - central_neutral_rho * A_eff, 0.0)) / mu.pt();
}

// find the indices of two good muons of different sign (minus, plus)
// If no such pair of muons is found, (-1, -1) is returned; this includes the case of more than two good muons.
pair<ssize_t, ssize_t> find_good_muons(const vector<pat::Muon> & muons, const reco::Vertex & pv, double central_neutral_rho){
    pair<ssize_t, ssize_t> result(-1, -1);
    ssize_t mu_minus_index = -1, mu_plus_index = -1;
    for(size_t i=0; i<muons.size(); ++i){
        const pat::Muon & muon = muons[i];
        // skip bad muons:
        if(!(muon.isTightMuon(pv) && muon.pt() > 20. && isolation_pat_ea04(muon, central_neutral_rho) < 0.2 && fabs(muon.eta() < 2.4))) continue;
        if(muon.charge() < 0){
            if(mu_minus_index > -1){ // found more than one tight muon
                return result;
            }
            else{
                mu_minus_index = i;
            }
        }
        else{// charge > 0
            if(mu_plus_index > -1){ // found more than one tight muon
                return result;
            }
            else{
                mu_plus_index = i;
            }
        }
    }
    return make_pair(mu_minus_index, mu_plus_index);
}



// try to match bhad with gen B and D hadrons with Delta R = 0.1.
// 0 = no match
// 1 = D meson, but no B
// 2 = both B and D match
// 3 = B but no D
int get_mc_origin(const Bhadron& bhad, const reco::GenParticleCollection& genpCol) {
    int ngenB = 0;
    int ngenD = 0;
    for(size_t ig = 0; ig<genpCol.size(); ig++){
        if(fabs(genpCol[ig].eta())<2.4 && genpCol[ig].pt()>0){
            float dR = deltaR(bhad.p4, genpCol[ig].p4());
            if(dR > 0.10) continue;
            HepPDT::ParticleID pid(genpCol[ig].pdgId());
            if(pid.isHadron()){
                if(pid.hasBottom()){
                    ngenB++;
                }
                else if(pid.hasCharm()){
                    ngenD++;
                }
            }
        }
    }
    if( ngenB>0 && ngenD==0 ) return 3;
    else if( ngenB>0 && ngenD>0 ) return 2;
    else if( ngenB==0 && ngenD>0 ) return 1;
    else return 0;
}


template<typename T, typename TCONSTRUCTOR>
T get(const edm::ParameterSet & pset, const std::string & name, const TCONSTRUCTOR & def){
    if(pset.exists(name)){
        return pset.getParameter<T>(name);
    }
    else{
        return T(def);
    }
}


}



class ZSVAnalysis : public edm::EDAnalyzer {

   public:
      explicit ZSVAnalysis(const edm::ParameterSet&);


   private:

      virtual void beginJob();
      virtual void endJob();
      virtual void analyze(const edm::Event&, const edm::EventSetup&);

      GlobalVector flightDirection(const reco::Vertex &pv, const reco::Vertex &sv );
      
      // fill event Bcand from Bhadron; MC information is taken from iEvent, if it is MC ...
      void fillBcands(const edm::Event & iEvent, const pat::JetCollection & jets, const vector<Bhadron> & bhadrons, vector<Bcand> & bcands);
      
      
      int nevents_total, nevents_dimu, nevents_selected;

      // ** for output
      edm::Service<TFileService> fs_;
      TTree *tEvent;
      event svevent;
      
      // ** configuration
      edm::InputTag bCandSrc, primaryVertexSrc, electronSrc, muonSrc;
      
      // variables for event selection:
      double minMll;

      // variables for SV selection:
      double minInvM, minDistSig3D, maxEtaVertex, minPtVertex;
      
      // matching radii:
      double drVertexJetMatching;
};

// ************************************************************************


ZSVAnalysis::ZSVAnalysis(const edm::ParameterSet& iConfig):
  bCandSrc(iConfig.getParameter<edm::InputTag>("bCandSrc")),
  primaryVertexSrc(iConfig.getParameter<edm::InputTag>("primaryVertexSrc")),
  electronSrc(get<edm::InputTag>(iConfig, "electronSrc", "")),
  muonSrc(get<edm::InputTag>(iConfig, "muonSrc", "patMuonsWithTrigger")),
  minMll(get<double>(iConfig, "minMll", 60.0)),
  minInvM(get<double>(iConfig, "minInvM",1.4)),
  minDistSig3D(get<double>(iConfig, "minDistSig3D",5.0)),
  maxEtaVertex(get<double>(iConfig, "maxEtaVertex",2.0)),
  minPtVertex(get<double>(iConfig, "minPtVertex",8.0))
{
    drVertexJetMatching = get<double>(iConfig, "drVertexJetMatching", 0.15);
    nevents_total = nevents_dimu = nevents_selected = 0;
}


void ZSVAnalysis::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup) {
    ++nevents_total;
    
    // fill the variables in svevent, in the order of their declaration:
    
    // Run info
    EventID eventId  = iEvent.id();
    svevent.runNo = eventId.run ();
    svevent.eventNo = eventId.event ();
    svevent.lumiNo = iEvent.luminosityBlock();

    
    // True pileup:
    if(!iEvent.isRealData()){
        edm::Handle<std::vector<PileupSummaryInfo> > pus;
        iEvent.getByLabel("addPileupInfo", pus);
        svevent.mc_true_pileup = pus->at(0).getTrueNumInteractions();
    }
    else{
        svevent.mc_true_pileup = numeric_limits<float>::quiet_NaN();
    }
    
    // MET:
    edm::Handle<std::vector<reco::PFMET> > mets;
    iEvent.getByLabel("pfMetT0pcT1Txy", mets);
    svevent.met = mets->at(0).p4().pt();
    svevent.met_phi = mets->at(0).p4().phi();
    
    // Leptons:
    
    // muons:
    edm::Handle<std::vector<pat::Muon> > hmuons;
    iEvent.getByLabel(muonSrc, hmuons);
    const std::vector<pat::Muon> & muons = *hmuons;
    
    edm::Handle<double> hcentral_neutral_rho;
    iEvent.getByLabel(edm::InputTag("kt6PFJetsCentralNeutral", "rho"), hcentral_neutral_rho);
    double central_neutral_rho = *hcentral_neutral_rho;
    
    edm::Handle<reco::VertexCollection> hpvs;
    iEvent.getByLabel(primaryVertexSrc, hpvs);
    const reco::VertexCollection & pvs = *hpvs;
  
    // electrons:
    /*edm::Handle<std::vector<pat::Electron> > helectrons;
    iEvent.getByLabel(electron_src, helectrons);
    const std::vector<pat::Electron> & electrons = *helectrons;*/
    
    
    // try to find a pair of good muons; return if we do not find one here with mll > minMll:
    pair<ssize_t, ssize_t> muon_indices = find_good_muons(muons, pvs[0], central_neutral_rho);
    if(muon_indices.first < 0 || muon_indices.second < 0) return;
    if((muons[muon_indices.first].p4() +  muons[muon_indices.second].p4()).M() < minMll) return;
    ++nevents_dimu;
    
    svevent.lepton_minus.pdgid = 13;
    svevent.lepton_minus.p4 = muons[muon_indices.first].p4();
    
    svevent.lepton_plus.pdgid = -13;
    svevent.lepton_plus.p4 = muons[muon_indices.second].p4();
    
    
    
    // secondary vertices:
    Handle<std::vector<reco::Vertex> > hsvc;
    iEvent.getByLabel(bCandSrc, hsvc);
    const std::vector<reco::Vertex> & svc = *hsvc;
           
    Handle<std::vector<reco::LeafCandidate> > hlcc;
    iEvent.getByLabel(bCandSrc, hlcc);
    const std::vector<reco::LeafCandidate> & lcc = *hlcc;
    
    if(lcc.size()!=svc.size()) {
        throw logic_error("collection size mismatch");
    }
    
    std::vector<Bhadron> selectedBcands, additionalBcands;
    
    for(unsigned int isv = 0; isv < svc.size(); isv++) {
        const Vertex & svertex = svc[isv];
        Bhadron oneBcand;
        oneBcand.flightdir = flightDirection(pvs[0], svertex);
        oneBcand.vertex = SecondaryVertex(pvs[0], svertex, oneBcand.flightdir, true);
        oneBcand.isSelected = lcc[isv].p4().M() > minInvM &&
              oneBcand.vertex.dist3d().significance() > minDistSig3D &&
              fabs(oneBcand.flightdir.eta()) < maxEtaVertex &&
              lcc[isv].p4().Pt() > minPtVertex;
        oneBcand.p4 = lcc[isv].p4();
        if(oneBcand.isSelected) selectedBcands.push_back(oneBcand);
        else additionalBcands.push_back(oneBcand);
    }
    
    if(selectedBcands.size() + additionalBcands.size()==0){
        return;
    }
    
    sort(selectedBcands.begin(), selectedBcands.end(), compareBCandbyPt());
    sort(additionalBcands.begin(), additionalBcands.end(), compareBCandbyPt());
    
    Handle<pat::JetCollection> hjets;
    iEvent.getByLabel("selectedPatJets", hjets);
    const pat::JetCollection & jets = *hjets;
    
    fillBcands(iEvent, jets, selectedBcands, svevent.selected_bcands);
    fillBcands(iEvent, jets, additionalBcands, svevent.additional_bcands);
      
    // JETS: 
    svevent.jets.clear();
    for(size_t i=0; i<jets.size(); ++i){
        svevent.jets.push_back(jet());
        svevent.jets.back().p4 = jets[i].p4();
        svevent.jets.back().btag = jets[i].bDiscriminator("combinedSecondaryVertexBJetTags");
    }

    ++nevents_selected;
    tEvent->Fill();
}


GlobalVector ZSVAnalysis::flightDirection(const reco::Vertex &pv, const reco::Vertex &sv){
  GlobalVector res(sv.position().X() - pv.position().X(),
                   sv.position().Y() - pv.position().Y(),
                   sv.position().Z() - pv.position().Z());
  return res;
}


void ZSVAnalysis::beginJob() {
  tEvent = fs_->make<TTree>("event","event");
  
#define BR(s) tEvent->Branch(#s, &svevent. s)
  
  BR(lumiNo); // tEvent->Branch("lumiNo", &svevent.lumiNo);

  BR(eventNo);
  BR(runNo);
  BR(mc_true_pileup);
  BR(met);
  BR(met_phi);
  
  BR(lepton_plus);
  BR(lepton_minus);
  
  BR(selected_bcands);
  BR(additional_bcands);
  
  BR(jets);
  
#undef BR
}

void ZSVAnalysis::endJob(){
    cout << "ZSVAnalysis: total events process: " << nevents_total << "; survived mll cut: " << nevents_dimu << "; selected: " << nevents_selected << endl;
}

void ZSVAnalysis::fillBcands(const edm::Event & iEvent, const pat::JetCollection & jets, const vector<Bhadron> & bhadrons, vector<Bcand> & bcands){
    bcands.clear();
    for( size_t jb = 0; jb < bhadrons.size(); jb++) {
        bcands.push_back(Bcand());
        Bcand & bcand = bcands.back();
        
        
        // fill mc_origin, if possible (=if not data):
        bcand.mc_origin = -1;
        if(!iEvent.isRealData()){
            Handle<GenParticleCollection> hgpc;
            iEvent.getByLabel("genParticles", hgpc);
            const GenParticleCollection & gpc = *hgpc;
            bcand.mc_origin = get_mc_origin(bhadrons[jb], gpc);
        }
        
        // jet matching:
        bcand.matched_jet_index = -1;
        for(size_t ij=0; ij<jets.size(); ++ij){
            float dr = deltaR(jets[ij].p4(), bhadrons[jb].p4);
            if(dr < drVertexJetMatching){
                bcand.matched_jet_index = ij;
                break;
            }
        }
        
        // fill all other variables of bcand:
        bcand.p4 = bhadrons[jb].p4;
        bcand.flightdir = bhadrons[jb].flightdir;
        bcand.dist3D    = bhadrons[jb].vertex.dist3d().value();
        bcand.distSig3D = bhadrons[jb].vertex.dist3d().significance();
        bcand.dist2D    = bhadrons[jb].vertex.dist2d().value();
        bcand.distSig2D = bhadrons[jb].vertex.dist2d().significance();
        bcand.ntracks    = bhadrons[jb].vertex.nTracks();
    }
}


DEFINE_FWK_MODULE(ZSVAnalysis);

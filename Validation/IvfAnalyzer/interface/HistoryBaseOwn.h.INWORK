#ifndef HistoryBaseOwn_h
#define HistoryBaseOwn_h

#include <set>
#include <typeinfo>

#include "SimDataFormats/TrackingAnalysis/interface/TrackingParticle.h"
#include "SimDataFormats/TrackingAnalysis/interface/TrackingParticleFwd.h"
#include "SimDataFormats/TrackingAnalysis/interface/TrackingVertex.h"
#include "SimDataFormats/TrackingAnalysis/interface/TrackingVertexContainer.h"

#include <map>
#include "TrackingTools/TransientTrack/interface/TransientTrackBuilder.h"
#include "TrackingTools/Records/interface/TransientTrackRecord.h"
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDFilter.h"
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/ServiceRegistry/interface/Service.h"

#include "DataFormats/Common/interface/Ref.h"
#include "DataFormats/TrackReco/interface/Track.h"
#include "FWCore/Utilities/interface/InputTag.h"

#include "SimTracker/TrackHistory/interface/VertexClassifier.h"
#include "SimTracker/TrackHistory/interface/TrackClassifier.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h" 
#include "DataFormats/BTauReco/interface/SecondaryVertexTagInfo.h"
#include "SimDataFormats/TrackingHit/interface/PSimHit.h"
#include "SimTracker/TrackAssociation/interface/TrackAssociatorByHits.h"
#include "SimTracker/VertexAssociation/interface/VertexAssociatorByTracks.h"
#include "SimTracker/Records/interface/TrackAssociatorRecord.h"

#include "Validation/IvfAnalyzer/interface/HistoryBaseOwn.h"

#include "CommonTools/RecoAlgos/interface/TrackingParticleSelector.h"

#include "DataFormats/GeometryVector/interface/VectorUtil.h"

// namespace {    
//     
// }

class VertexRefProxy
    {
    public:
	VertexRefProxy()	//! code may fail because it tries to create more than one nullRef objects, possibly because of some memory address issues; maybe make it non-nested class?
	{
	    genVertexRef_ = NULL;
	    TrackingVertexRef newRef;
	    trackVertexRef_ = newRef;
	    pdgId_ = -1;
	    status_ = -1;
	}
	
	VertexRefProxy(const HepMC::GenParticle * genPtcl)
	{
	    genVertexRef_ = genPtcl->production_vertex();
	    TrackingVertexRef newRef;
	    trackVertexRef_ = newRef;
	    pdgId_ = std::abs(genPtcl->pdg_id());
	    status_ = genPtcl->status();
	}
	
	VertexRefProxy(const TrackingParticleRef & trkPtcl)
	{
	    if ( !trkPtcl->genParticle().empty() )
	    {
		genVertexRef_ = (*trkPtcl->genParticle_begin())->production_vertex();
// 		genVertexRef_.reset(genParent);
		TrackingVertexRef newRef;
		trackVertexRef_ = newRef;
	    } else if (trkPtcl->parentVertex().isNonnull())
	    {
		genVertexRef_ = NULL;
		trackVertexRef_ = trkPtcl->parentVertex();
	    }
	    else
		VertexRefProxy();
	    
	    pdgId_ = std::abs(trkPtcl->pdgId());
	    status_ = 1;
	}
	
	VertexRefProxy( const VertexRefProxy & vrp)
	{
// 	    HepMC::GenVertex * newGenVtx = const_cast<HepMC::GenVertex *>(&vrp.getGVRef());
	    genVertexRef_ = const_cast<HepMC::GenVertex *>(vrp.getGVRef());
	    trackVertexRef_ = vrp.getTVRef();
	    pdgId_ = vrp.getPdgId();
	    status_ = vrp.getStatus();
	}
	
	~VertexRefProxy() {};
	
	const TrackingVertexRef & getTVRef() const { return trackVertexRef_; }
	HepMC::GenVertex const * getGVRef() const { return genVertexRef_; }
	
	int getPdgId() const {return pdgId_; }
	
	int getStatus() const {return status_;}
	
	bool isNonnull() const { return (genVertexRef_ || trackVertexRef_.isNonnull()) ? true : false;}
	
	bool hasTrkVertex() const { return (trackVertexRef_.isNonnull()) ? true : false; }
	
	bool hasGenVertex() const { return (genVertexRef_) ? true : false; }
	
// 	void setVertex(HepMC::GenVertex* genVertex) 
// 	{
// 	    genVertexRef_.reset(genVertex);
// 	    TrackingVertexRef newRef;
// 	    trackVertexRef_ = newRef;
// 	}
// 	void setVertex(TrackingVertexRef trackVertex)
// 	{
// 	    trackVertexRef_ = trackVertex;
// 	    genVertexRef_.reset(new HepMC::GenVertex);
// 	}
	
    private:
	HepMC::GenVertex* genVertexRef_; /// use TrackingVertex::GenVertexRef instead
	TrackingVertexRef trackVertexRef_;
	int pdgId_;
	int status_;
};


//! Base class to all the history types.
class HistoryBaseOwn
{

public:
  
  struct G4
  {
    enum Process
    {
      Undefined = 0,
      Unknown,
      Primary,
      Hadronic,
      Decay,
      Compton,
      Annihilation,
      EIoni,
      HIoni,
      MuIoni,
      Photon,
      MuPairProd,
      Conversions,
      EBrem,
      SynchrotronRadiation,
      MuBrem,
      MuNucl	    
    };
    
  };
  
  enum Category
  {
    Fake = 0,
    HadronicProcess,
    UnknownProcess,
    UndefinedProcess,
    GeantPrimaryProcess,
    DecayProcess,
    ComptonProcess,
    AnnihilationProcess,
    EIoniProcess,
    HIoniProcess,
    MuIoniProcess,
    PhotonProcess,
    MuPairProdProcess,
    ConversionsProcess,
    EBremProcess,
    SynchrotronRadiationProcess,
    MuBremProcess,
    MuNuclProcess,
    PrimaryProcess,
    ProtonDecay,
    BWeakDecay,
    CWeakDecay,
    FromBWeakDecayMuon,
    FromCWeakDecayMuon,
    ChargePionDecay,
    ChargeKaonDecay,
    TauDecay,
    KsDecay,
    LambdaDecay,
    JpsiDecay,
    XiDecay,
    SigmaPlusDecay,
    SigmaMinusDecay    
  };

    //! GenParticle trail type.
    typedef std::vector<const HepMC::GenParticle *> GenParticleTrail;

    //! GenVertex trail type.
    typedef std::vector<const HepMC::GenVertex *> GenVertexTrail;

    //! GenVertex trail helper type.
    typedef std::set<const HepMC::GenVertex *> GenVertexTrailHelper;

    //! SimParticle trail type.
    typedef std::vector<TrackingParticleRef> SimParticleTrail;

    //! SimVertex trail type.
    typedef std::vector<TrackingVertexRef> SimVertexTrail;
    
    typedef std::vector<double> Flags;
    
    
    

    // Default constructor
    HistoryBaseOwn()
    {
        // Default depth
        status_ = 1;
	
	debugMsg_ = false;
    }
    
    void status(int d)
    {
        status_ = d;
    }
    
    void newEvent(const edm::EventSetup& setup) { setup.getData(particleDataTable_); }
    
    void reset()
    {
      historyFlags_ = Flags(SigmaMinusDecay + 1, 0.);
    }

    //! Return all the simulated vertices in the history.
//     SimVertexTrail const & simVertexTrail() const
//     {
//         return simVertexTrail_;
//     }
// 
//     //! Return all the simulated particle in the history.
//     SimParticleTrail const & simParticleTrail() const
//     {
//         return simParticleTrail_;
//     }
// 
//     //! Return all generated vertex in the history.
//     GenVertexTrail const & genVertexTrail() const
//     {
//         return genVertexTrail_;
//     }
// 
//     //! Return all generated particle in the history.
//     GenParticleTrail const & genParticleTrail() const
//     {
//         return genParticleTrail_;
//     }
// 
//     //! Return the initial tracking particle from the history.
//     const TrackingParticleRef & simParticle() const
//     {
//         return simParticleTrail_[0];
//     }
// 
//     //! Return the initial tracking vertex from the history.
//     const TrackingVertexRef & simVertex() const
//     {
//         return simVertexTrail_[0];
//     }

//     const HepMC::GenParticle * genParticle() const
//     {
//         if ( genParticleTrail_.empty() ) return 0;
//         return genParticleTrail_[genParticleTrail_.size()-1];
//     }
    
    void debugMsg(bool debug) { debugMsg_ = debug; }
    
    double getHistoryWeight(Category category) const
    {
      return historyFlags_[category];
    }
    
    Flags const & getHistoryProcessFlags() { return historyFlags_; }
    
    void flagProcess(Flags &, int, double, bool cumulative = true);
    
    TrackingParticleRef getSourceTrack(TrackingVertexRef const &);	/// later try 'TrackingParticleRef getSourceTrack(TrackingVertexRef &) const;' without overloading the function
    
    TrackingParticleRef getSourceTrack(TrackingVertexRef & trackVertRef)
    {
      TrackingVertexRef const & inputVertRef = trackVertRef;
      return getSourceTrack(inputVertRef);
    }
    
    double distanceToPrevVertex(HepMC::GenVertex const *, HepMC::GenVertex const *);
    
    //! Trace all the simulated information for a given reference to a TrackingVertex.
    VertexRefProxy getVertexParent (TrackingVertexRef const &);
    
    //! Trace all the simulated information for a given pointer to a GenParticle.
    //     bool traceGenHistory (HepMC::GenParticle const *, Flags &, int, double);
    
    //! Trace all the simulated information for a given pointer to a GenVertex.
    VertexRefProxy getVertexParent (HepMC::GenVertex const *);
    
    VertexRefProxy getVertexParent(VertexRefProxy const & vrp)
    {
	VertexRefProxy nullRef;
	if (vrp.hasTrkVertex() && !vrp.hasGenVertex()) {return getVertexParent(vrp.getTVRef()); }
	else if (vrp.hasGenVertex() && !vrp.hasTrkVertex()) {return getVertexParent(vrp.getGVRef()); }
	else return nullRef;
    }

protected:
    
    int status_;
    
    bool debugMsg_;
    
    Flags historyFlags_;
    
    edm::ESHandle<ParticleDataTable> particleDataTable_;

    // History cointainers
//     GenVertexTrail genVertexTrail_;
//     GenParticleTrail genParticleTrail_;
//     SimVertexTrail simVertexTrail_;
    SimParticleTrail simParticleTrail_;	// only to check for looping tracks

    // Helper function to speedup search
    GenVertexTrailHelper genVertexTrailHelper_;

    //! Evaluate track history using a TrackingParticleRef.
    
//     bool evaluate(TrackingParticleRef const & tpr, Flags & flags, int histSteps, double weight)
//     {
// 	histSteps_ = histSteps;
//         resetTrails(tpr);
// 	return traceSimHistory(tpr, flags, 0, weight);
//     }
// 
//     //! Evaluate track history using a TrackingParticleRef.
//     
//     bool evaluate(TrackingVertexRef const & tvr, Flags & flags, int histSteps, double weight)
//     {
// 	histSteps_ = histSteps;
//         resetTrails();
//         return traceSimHistory(tvr, flags, 0, weight);
//     }

private:

    int histSteps_;
    
//     int historySteps_;

    //! Trace all the simulated information for a given reference to a TrackingParticle.
//     bool traceSimHistory (TrackingParticleRef const &, Flags &, int, double);

    //! Reset trail functions.
    void resetTrails()
    {
        simParticleTrail_.clear();
//         simVertexTrail_.clear();
//         genVertexTrail_.clear();
//         genParticleTrail_.clear();
        genVertexTrailHelper_.clear();
    }

    void resetTrails(TrackingParticleRef tpr)
    {
        resetTrails();
        simParticleTrail_.push_back(tpr);
    }
};

#endif
